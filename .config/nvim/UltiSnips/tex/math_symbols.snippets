# Define the math context - credit: Gilles Castel
global !p
def math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '1' or env('tikzcd')

def comment():
	return vim.eval('vimtex#syntax#in_comment()') == '1'

def env(name):
	[x,y] = vim.eval('vimtex#env#is_inside(\'' + name + '\')')
	return x != '0' and y != '0'
endglobal



priority 1

# COMMON SETS #
context "math()"
snippet NN "natural numbers" iA
\mathbf{N}
endsnippet

context "math()"
snippet ZZ "integers" iA
\mathbf{Z}
endsnippet

context "math()"
snippet QQ "rational numbers" iA
\mathbf{Q}
endsnippet

context "math()"
snippet RR "real numbers" iA
\mathbf{R}
endsnippet

context "math()"
snippet CC "complex numbers" iA
\mathbf{C}
endsnippet

context "math()"
snippet FF "finite field" iA
\mathbf{F}
endsnippet

context "math()"
snippet SS "caligraphy S" iA
\mathcal{S}
endsnippet

context "math()"
snippet HH "caligraphy H" iA
\mathcal{H}
endsnippet

priority 11
context "math()"
snippet Cinf "C infinity" iA
\mathcal{C}^{\infty}
endsnippet

priority 1

context "math()"
snippet linH "linear maps on H" iA
\mathcal{L}(\mathcal{H})
endsnippet

context "math()"
snippet hom "homset" iA
\mathrm{Hom}
endsnippet



# GENERAL SYMBOLS #
context "math()"
snippet AA "for all" iA
\forall
endsnippet

context "math()"
snippet EE "there exists" iA
\exists
endsnippet

context "math()"
snippet ini "element of" iA
\in
endsnippet

priority 10
context "math()"
snippet nini "not element of" iA
\not\in
endsnippet
priority 1

context "math()"
snippet cc "subset" iA
\subseteq
endsnippet

context "math()"
snippet cC "superset" iA
\supseteq
endsnippet

context "math()"
snippet sem "setminus" iA
\setminus
endsnippet

context "math()"
snippet emp "empty set" iA
\emptyset
endsnippet

context "math()"
snippet neq "not equal to" iA
\neq
endsnippet

context "math()"
snippet geg "greater than or equal to" iA
\ge
endsnippet

context "math()"
snippet lel "less than or equal to" iA
\le
endsnippet

context "math()"
snippet >> "way greater than" iA
\gg
endsnippet

context "math()"
snippet << "way smaller than" iA
\ll
endsnippet

context "math()"
snippet ... "ellipsis" iA
\dots
endsnippet

context "math()"
snippet xx "cross" iA
\times
endsnippet

context "math()"
snippet xox "tensor" iA
\otimes
endsnippet

context "math()"
snippet ** "dot" iA
\cdot
endsnippet

context "math()"
snippet mid "divisible by" iA
\mid
endsnippet

context "math()"
snippet nmid "not divisible by" iA
\nmid
endsnippet

context "math()"
snippet '(?<!\\)inf' "infinity" iAr
\infty
endsnippet

context "math()"
snippet uu "set union" iA
\cup
endsnippet

context "math()"
snippet nn "set intersection" iA
\cap
endsnippet

context "math()"
snippet Uu "big set union" iA
\bigcup
endsnippet

context "math()"
snippet Nn "big set intersection" iA
\bigcap
endsnippet

context "math()"
snippet cir "circle" iA
\circ
endsnippet

context "math()"
snippet lll "ell" iA
\ell
endsnippet

context "math()"
snippet sim "text tilde" iA
\sim
endsnippet

priority 10
context "math()"
snippet '(?<!\\)hbar' "reduced Planck's constant" riA
\hbar
endsnippet
priority 1



# DIFFERENTIALS #
context "math()"
snippet DD "differential" iA
\dd{$1}$0
endsnippet

context "math()"
snippet part "partial" iA
\partial
endsnippet

context "math()"
snippet nab "nabla" iA
\nabla
endsnippet



# GREEK LETTERS #
context "math()"
snippet hal "alpha" iA
\alpha
endsnippet

context "math()"
snippet hbe "beta" iA
\beta
endsnippet

context "math()"
snippet 'h(g+)a' "gamma" iAr
`!p
gs = match.group(1)
if len(gs) == 1:
	snip.rv = "\\gamma"
elif len(gs) == 2:
	snip.rv = "\\Gamma"
else:
	snip.rv = "h" + gs + "a"
`
endsnippet

context "math()"
snippet 'h(d+)e' "delta" iAr
`!p
ds = match.group(1)
if len(ds) == 1:
	snip.rv = "\\delta"
elif len(ds) == 2:
	snip.rv = "\\Delta"
else:
	snip.rv = "h" + ds + "e"
`
endsnippet

context "math()"
snippet '(v?)eps' "(var)epsilon" iAr
`!p
v = match.group(1)
if len(v) == 0:
	snip.rv = "\\epsilon"
else:
	snip.rv = "\\varepsilon"
`
endsnippet

context "math()"
snippet hze "zeta" iA
\zeta
endsnippet

context "math()"
snippet het "eta" iA
\eta
endsnippet

context "math()"
snippet hte "theta" iA
\theta
endsnippet

context "math()"
snippet gio "iota" iA
\iota
endsnippet

context "math()"
snippet gka "kappa" iA
\kappa
endsnippet

context "math()"
snippet 'g(l+)a' "lambda" iAr
`!p
ls = match.group(1)
if len(ls) == 1:
	snip.rv = "\\lambda"
elif len(ls) == 2:
	snip.rv = "\\Lambda"
else: # this will be overwritten by \ell snippet with triggers on 'lll'
	snip.rv = "g" + ls + "a"
`
endsnippet

context "math()"
snippet gmu "mu" iA
\mu
endsnippet

context "math()"
snippet gnu "nu" iA
\nu
endsnippet

context "math()"
snippet gks "xi" iA
\xi
endsnippet

# \omikron doesn't exist

context "math()"
snippet gpi "pi" iA
\pi
endsnippet

context "math()"
snippet hro "rho" iA
\rho
endsnippet

context "math()"
snippet hsi "sigma" iA
\sigma
endsnippet

context "math()"
snippet hta "tau" iA
\tau
endsnippet

# \upsilon looks like math v and is never used

context "math()"
snippet '(?<!\\var)(?<!\\)(v?)phi' "phi" iAr
`!p
v = match.group(1)
if len(v) == 0:
	snip.rv = "\\phi"
else:
	snip.rv = "\\varphi"
`
endsnippet

context "math()"
snippet hffi "capital phi" iA
\Phi
endsnippet

context "math()"
snippet hch "chi" iA
\chi
endsnippet

context "math()"
snippet '(?<!\\)(p+)si' "psi" iAr
`!p
ps = match.group(1)
if len(ps) == 1:
	snip.rv = "\\psi"
elif len(ps) == 2:
	snip.rv = "\\Psi"
else:
	snip.rv = "g" + ps + "s"
`
endsnippet

context "math()"
snippet 'g(o+)m' "omega" iAr
`!p
os = match.group(1)
if len(os) == 1:
	snip.rv = "\\omega"
elif len(os) == 2:
	snip.rv = "\\Omega"
else:
	snip.rv = "g" + os + "m"
`
endsnippet



# SUBSCRIPTS AND SUPERSCRIPTS #
context "math()"
snippet ';(\w)' "single character subscript" iAr
_`!p snip.rv = match.group(1)`
endsnippet

context "math()"
snippet ;; "subscript" iA
_{$1}$0
endsnippet

context "math()"
snippet __ "underscore" iA
\_
endsnippet

context "math()"
snippet ':(\w)' "single character superscript" iAr
^`!p snip.rv = match.group(1)`
endsnippet

context "math()"
snippet td "superscript" iA
^{$1}$0
endsnippet

context "math()"
snippet sr "squared" iA
^2
endsnippet

context "math()"
snippet invs "inverse" iA
^{-1}
endsnippet

context "math()"
snippet com "complement" iA
^{c}
endsnippet

context "math()"
snippet '(?<!\\)con' "conjugate" iAr
^{*}
endsnippet

context "math()"
snippet ttt "transpose" iA
^{\top}
endsnippet

context "math()"
snippet perp "perpendicular" iA
^{\bot}
endsnippet

context "math()"
snippet adj "adjoint" iA
^{\dagger}
endsnippet



# SPECIAL FUNCTIONS #
context "math()"
snippet sqr "square root" iA
\sqrt{$1}$0
endsnippet

priority 10
context "math()"
snippet nsqr "nth root" iA
\sqrt[$1]{$2}$0
endsnippet
priority 1

context "math()"
snippet '(sin|cos|tan|ln|log|det|dim|ker)' "auto-backslash" wAr
`!p snip.rv = "\\" + match.group(1)`
endsnippet

priority 10
context "math()"
snippet 'a(sin|cos|tan)' "inverse trig" wAr
`!p snip.rv = "\\arc" + match.group(1)`
endsnippet

context "math()"
snippet coker "cokernel" wAi
\mathrm{coker}
endsnippet
priority 1

context "math()"
snippet binom "binomial coefficient" iA
\binom{${1:n}}{${2:k}}$0
endsnippet



# SUMS PRODUCTS LIMITS INTEGRALS #
context "math()"
snippet sum "sum" iA
\sum
endsnippet

context "math()"
snippet '(?<!\\ap)pro' "product" iAr
\prod
endsnippet

context "math()"
snippet lim "limit" iA
\lim_{${1:n\to\infty}}$0
endsnippet

context "math()"
snippet '(i+)nt' "integral" iAr
`!p
i = match.group(1)
if len(i) <= 3:
	snip.rv = "\\" + i + "nt"
else:
	snip.rv = i + "nt"
`
endsnippet

priority 10
context "math()"
snippet dsum "sum with limits" iA
\sum_{${1:n=0}}^{${2:\infty}}$0
endsnippet

context "math()"
snippet dpro "product with limits" iA
\prod_{${1:n=0}}^{${2:\infty}}$0
endsnippet

context "math()"
snippet dint "definite integral" iA
\int_{${1:0}}^{${2:\infty}}$0
endsnippet
priority 1



# ARROWS #
context "math()"
snippet imp "implies" iA
\implies
endsnippet

context "math()"
snippet pmi "implied by" iA
\impliedby
endsnippet

context "math()"
snippet iff "if and only if" iA
\iff
endsnippet

context "math()"
snippet rar "right arrow" iA
\to
endsnippet

context "math()"
snippet mar "mapsto arrow" iA
\mapsto
endsnippet

priority 10
context "math()"
snippet mmar "long mapsto arrow" iA
\longmapsto
endsnippet

context "math()"
snippet rrar "long right arrow" iA
\longrightarrow
endsnippet
priority 1

